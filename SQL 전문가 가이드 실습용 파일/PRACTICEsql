REM 다중행 서브 쿼리
SELECT PLAYER_NAME 선수명, POSITION 포지션, BACK_NO 백넘버
FROM PLAYER
WHERE (TEAM_ID, HEIGHT) IN (SELECT TEAM_ID, MIN(HEIGHT)
                 FROM PLAYER
                 GROUP BY TEAM_ID)
ORDER BY PLAYER_NAME;

REM 연관 서브 쿼리1
SELECT T.TEAM_NAME 팀명, M.PLAYER_NAME 선수명, M.POSITION 포지션, M.BACK_NO 백넘버, M.HEIGHT 키
FROM PLAYER M, TEAM T
WHERE M.TEAM_ID = T.TEAM_ID AND M.HEIGHT < (SELECT AVG(S.HEIGHT)
                                            FROM PLAYER S
                                            WHERE S.TEAM_ID = M.TEAM_ID AND S.HEIGHT IS NOT NULL
                                            GROUP BY S.TEAM_ID)
ORDER BY 선수명;

REM 연관 서브 쿼리2
SELECT STADIUM_ID ID, STADIUM_NAME 경기장명
FROM STADIUM A
WHERE EXISTS (SELECT 1
              FROM SCHEDULE X
              WHERE X.STADIUM_ID = A.STADIUM_ID AND X.SCHE_DATE BETWEEN '20120501' AND '20120502');


SELECT STADIUM_ID ID, STADIUM_NAME 경기장명
FROM STADIUM;
SELECT * FROM SCHEDULE WHERE SCHE_DATE BETWEEN '20120501' AND '20120502';

REM FROM절에서 서브쿼리 사용하기1
SELECT T.TEAM_NAME 팀명, P.PLAYER_NAME 선수명, P.BACK_NO 백넘버
FROM (SELECT TEAM_ID, PLAYER_NAME, BACK_NO
      FROM PLAYER
      WHERE POSITION='MF') P, TEAM T
WHERE P.TEAM_ID = T.TEAM_ID
ORDER BY 선수명;

REM FROM절에서 서브쿼리 사용하기2
SELECT PLAYER_NAME 선수명, POSITION 포지션, BACK_NO 백넘버, HEIGHT 키
FROM (SELECT PLAYER_NAME, POSITION, BACK_NO, HEIGHT
      FROM PLAYER
      WHERE HEIGHT IS NOT NULL
      ORDER BY HEIGHT DESC)
WHERE ROWNUM <=5;

REM HAVING절에서 서브쿼리 사용하기
SELECT P.TEAM_ID 팀코드, T.TEAM_NAME 팀명, AVG(P.HEIGHT) 평균키
FROM PLAYER P, TEAM T
WHERE P.TEAM_ID = T.TEAM_ID
GROUP BY P.TEAM_ID, T.TEAM_NAME
HAVING AVG(P.HEIGHT) < (SELECT AVG(HEIGHT)
                        FROM PLAYER
                        WHERE TEAM_ID = 'KO2');
                        
REM UPDATE문의 SET절에서 사용하기
UPDATE TEAM A
SET A.STADIUM_NAME = (SELECT X.STADIUM_NAME
                      FROM STADIUM X
                      WHERE X.STADIUM_ID = A.STADIUM_ID);
                      
REM INSERT문의 VALUES절에서 사용하기
INSERT INTO PLAYER(PLAYER_ID, PLAYER_NAME, TEAM_ID)
VALUES ((SELELCT TO_CHAR(MAX(TO_NUMBER(PLAYER_ID))+1)
FROM PLAYER), '홍길동', 'K06');

REM 뷰 생성, 삭제

CREATE VIEW V_PLAYER_TEAM
AS SELECT P.PLAYER_NAME, P.POSITION, P.BACK_NO, P.TEAM_ID, T.TEAM_NAME
   FROM PLAYER P, TEAM T
   WHERE P.TEAM_ID = T.TEAM_ID;

CREATE VIEW V_PLAYER_TEAM_FILTER
AS SELECT PLAYER_NAME, POSITION, BACK_NO, TEAM_NAME
   FROM V_PLAYER_TEAM
   WHERE POSITION IN ('GK', 'MF')
   
DROP VIEW V_PLAYER_TEAM;
DROP VIEW V_PLAYER_TEAM_FILTER;

   
REM 뷰 사용

SELECT PLAYER_NAME, POSITION, BACK_NO, TEAM_ID, TEAM_NAME
FROM V_PLAYER_NAME
WHERE PLAYER_NAME LIKE '황%';

REM ROLLUP함수-1.1 일반적인 GROUP BY 절 함수

SELECT DNAME, JOB,
       COUNT(*) "TOTAL EMPL",
       SUM(SAL) "TOTAL SAL"
FROM EMP, DEPT
WHERE DEPT.DEPTNO =EMP.DEPTNO
GROUP BY DNAME, JOB;

REM ROLLUP함수-1.2 GROUP BY + ORDER BY 절 함수
SELECT DNAME, JOB,
       COUNT(*) "TOTAL EMPL",
       SUM(SAL) "TOTAL SAL"
FROM EMP, DEPT
WHERE DEPT.DEPTNO =EMP.DEPTNO
GROUP BY DNAME, JOB
ORDER BY DNAME, JOB;

REM ROLLUP함수-1.3 GROUP BY 절에 ROLLUP 함수 사용

SELECT DNAME, JOB,
       COUNT(*) "TOTAL EMPL",
       SUM(SAL) "TOTAL SAL"
FROM EMP, DEPT
WHERE DEPT.DEPTNO =EMP.DEPTNO
GROUP BY ROLLUP(DNAME, JOB);

REM ROLLUP함수-1.4 GROUP BY 절에 ROLLUP 함수 + ORDER BY 사용

SELECT DNAME, JOB,
       COUNT(*) "TOTAL EMPL",
       SUM(SAL) "TOTAL SAL"
FROM EMP, DEPT
WHERE DEPT.DEPTNO =EMP.DEPTNO
GROUP BY ROLLUP(DNAME, JOB)
ORDER BY DNAME, JOB;

REM ROLLUP함수-1.5 GROUPING 함수 사용
SELECT DNAME, GROUPING(DNAME),
       JOB, GROUPING(JOB),
       COUNT(*) "TOTAL EMPL",
       SUM(SAL) "TOTAL SAL"
FROM EMP, DEPT
WHERE DEPT.DEPTNO =EMP.DEPTNO
GROUP BY ROLLUP(DNAME, JOB);

REM ROLLUP함수-1.6 GROUPING 함수 + CASE 함수사용
SELECT CASE GROUPING(DNAME) WHEN 1 THEN 'ALL DEPARTMENT' ELSE DNAME END AS DNAME,
       CASE GROUPING(JOB) WHEN 1 THEN 'ALL JOBS' ELSE JOB END AS JOB,
       COUNT(*) "TOTAL EMPL",
       SUM(SAL) "TOTAL SAL"
FROM EMP, DEPT
WHERE DEPT.DEPTNO = EMP.DEPTNO
GROUP BY ROLLUP(DNAME, JOB);

REM ROLLUP함수-1.7 GROUPING 함수 + ORACLE의 경우 DECODE 함수사용
SELECT DECODE(GROUPING(DNAME), 1, 'ALL DEPARTMENT', DNAME) AS DNAME,
       DECODE(GROUPING(JOB), 1, 'ALL JOBS', JOB) AS JOB,
       COUNT(*) "TOTAL EMPL",
       SUM(SAL) "TOTAL SAL"
FROM EMP, DEPT
WHERE DEPT.DEPTNO =EMP.DEPTNO
GROUP BY ROLLUP(DNAME, JOB);

REM ROLLUP함수-1.8 ROLLUP 함수 일부 사용

SELECT CASE GROUPING(DNAME) WHEN 1 THEN 'ALL DEPARTMENT' ELSE DNAME END AS DNAME,
       CASE GROUPING(JOB) WHEN 1 THEN 'ALL JOBS' ELSE JOB END AS JOB,
       COUNT(*) "TOTAL EMPL",
       SUM(SAL) "TOTAL SAL"
FROM EMP, DEPT
WHERE DEPT.DEPTNO = EMP.DEPTNO
GROUP BY DNAME, ROLLUP(JOB);

REM ROLLUP함수-1.9 ROLLUP 함수 결합 칼럼 사용
REM 괄호로 묶은 JOB과 MGR의 경우 하나의 집합(JOB+MGR) 칼럼으로 간주하여 칼럼별 집계를 구하지 않는다.
SELECT DNAME, JOB, MGR, SUM(SAL) "TOTAL SAL"
FROM EMP, DEPT
WHERE DEPT.DEPTNO = EMP.DEPTNO
GROUP BY ROLLUP(DNAME, (JOB, MGR));

REM CUBE함수 사용
SELECT
CASE GROUPING(DNAME) WHEN 1 THEN 'ALL DEPARTMENT' ELSE DNAME END AS DNAME,
CASE GROUPING(JOB) WHEN 1 THEN 'ALL JOBS' ELSE JOB END AS JOB,
COUNT(*) "TOTAL EMPL",
SUM(SAL) "TOTAL SAL"
FROM EMP, DEPT
WHERE DEPT.DEPTNO = EMP.DEPTNO
GROUP BY CUBE(DNAME, JOB);

REM GROUPING SETS1-일반 그룹함수를 이용한 SQL

SELECT DNAME, 'ALL JOBS' JOB, COUNT(*) "TOTAL EMPL", SUM(SAL) "TOTAL SAL"
FROM EMP, DEPT
WHERE DEPT.DEPTNO = EMP.DEPTNO
GROUP BY DNAME

UNION ALL

SELECT 'ALL DEPARTMENT' DNAME, JOB, COUNT(*) "TOTAL EMPL", SUM(SAL) "TOTAL SAL"
FROM EMP, DEPT
WHERE DEPT.DEPTNO = EMP.DEPTNO
GROUP BY JOB;

REM GROUPING SETS2-GROUPING SETS(DNAME, JOB)을 이용한 SQL

SELECT DECODE(GROUPING(DNAME), 1, 'ALL DEPARTMENT', DNAME) AS DNAME,
       DECODE(GROUPING(JOB), 1, 'ALL JOBS', JOB) AS JOB,
       COUNT(*) "TOTAL EMPL",
       SUM(SAL) "TOTAL SAL"
FROM EMP, DEPT
WHERE DEPT.DEPTNO = EMP.DEPTNO
GROUP BY GROUPING SETS(DNAME, JOB);

REM GROUPING SETS3-GROUPING SETS(JOB, DNAME)을 이용한 SQL

SELECT DECODE(GROUPING(DNAME), 1, 'ALL DEPARTMENT', DNAME) AS DNAME,
       DECODE(GROUPING(JOB), 1, 'ALL JOBS', JOB) AS JOB,
       COUNT(*) "TOTAL EMPL",
       SUM(SAL) "TOTAL SAL"
FROM EMP, DEPT
WHERE DEPT.DEPTNO = EMP.DEPTNO
GROUP BY GROUPING SETS(JOB, DNAME);

REM GROUPING SETS4-3개의 인수를 이용한 GROUPING SETS의 이용
SELECT DNAME, JOB, MGR, SUM(SAL) "TOTAL SAL"
FROM EMP, DEPT
WHERE DEPT.DEPTNO = EMP.DEPTNO
GROUP BY GROUPING SETS((DNAME, JOB, MGR), (DNAME, MGR), (JOB, MGR));

REM 윈도우 함수- 그룹내 순위함수 RANK 함수

SELECT JOB, ENAME, SAL,
       RANK() OVER (ORDER BY SAL DESC) ALL_RANK,
       RANK() OVER (PARTITION BY JOB ORDER BY SAL DESC) JOB_RANK
FROM EMP;

SELECT JOB, ENAME, SAL,
       RANK() OVER (PARTITION BY JOB ORDER BY SAL DESC) JOB_RANK
FROM EMP;

REM 윈도우 함수- 그룹내 순위함수 RANK, DENSE_RANK, ROW_NUMBER 함수

SELECT JOB, ENAME, SAL,
       RANK() OVER (ORDER BY SAL DESC) RANK,
       DENSE_RANK() OVER (ORDER BY SAL DESC) DENSE_RANK,
       ROW_NUMBER() OVER (ORDER BY SAL DESC) ROW_NUMBER
FROM EMP;

REM 일반 집계 함수-SUM 함수

SELECT MGR, ENAME, SAL, SUM(SAL) OVER (PARTITION BY MGR) MGR_SUM
FROM EMP;

REM 일반 집계 함수-SUM 함수 + OVER절 내에 ORDER BY 절 추가, 누적값 출력

SELECT MGR, ENAME, SAL, SUM(SAL) OVER (PARTITION BY MGR ORDER BY SAL RANGE UNBOUNDED PRECEDING) AS MGR_SUM
FROM EMP;

REM 일반 집계 함수- MAX 함수
SELECT MGR, ENAME, SAL, MAX(SAL) OVER (PARTITION BY MGR) AS MGR_MAX
FROM EMP;

REM 일반 집계 함수- MAX 함수, MAX값을 가지는 행만 추출
SELECT MGR, ENAME, SAL
FROM (SELECT MGR, ENAME, SAL, MAX(SAL) OVER (PARTITION BY MGR) AS MGR_MAX
FROM EMP)
WHERE SAL=MGR_MAX;

REM 일반 집계 함수- MIN 함수
SELECT MGR, ENAME, SAL, MIN(SAL) OVER (PARTITION BY MGR) AS MGR_MIN
FROM EMP;

REM 일반 집계 함수- MIN 함수, MIN값을 가지는 행만 추출
SELECT MGR, ENAME, SAL
FROM (SELECT MGR, ENAME, SAL, MIN(SAL) OVER (PARTITION BY MGR) AS MGR_MIN
FROM EMP)
WHERE SAL=MGR_MIN;

REM 일반 집계 함수-AVG 함수
SELECT MGR, ENAME, HIREDATE, SAL,
       ROUND( AVG(SAL) OVER (PARTITION BY MGR ORDER BY HIREDATE
            ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING)) AS MGR_AVG
FROM EMP;

REM 일반 집계 함수-COUNT 함수 , 범위 구간 정하기

SELECT ENAME, SAL, COUNT(*) OVER (ORDER BY SAL RANGE BETWEEN 50 PRECEDING AND 150 FOLLOWING ) AS SIM_CNT
FROM EMP;

REM 그룹내 행 순서 함수-FIRST_VALUE 함수

SELECT DEPTNO, ENAME, SAL, FIRST_VALUE(ENAME) OVER (PARTITION BY DEPTNO ORDER BY SAL DESC ROWS UNBOUNDED PRECEDING) AS DEPT_RICH
FROM EMP;

REM 그룹내 행 순서 함수-FIRST_VALUE 함수, 값이 같은 경우 ENAME으로 한번더 정렬

SELECT DEPTNO, ENAME, SAL, FIRST_VALUE(ENAME) OVER (PARTITION BY DEPTNO ORDER BY SAL DESC, ENAME ASC ROWS UNBOUNDED PRECEDING) AS DEPT_RICH
FROM EMP;

REM 그룹내 행 순서 함수-LAST_VALUE 함수

SELECT DEPTNO, ENAME, SAL, LAST_VALUE(ENAME) OVER (PARTITION BY DEPTNO ORDER BY SAL DESC ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING) AS DEPT_POOR
FROM EMP;

REM 그룹내 행 순서 함수-LAG 함수

SELECT ENAME, HIREDATE, SAL, LAG(SAL) OVER (ORDER BY HIREDATE ) AS PREV_SAL
FROM EMP
WHERE JOB='SALESMAN';

REM 그룹내 행 순서 함수-LAG 함수, LAG(적용할 칼럼, 몇번째 앞의 숫자를 가져올건지, NULL값일때 어떤값으로 표기할건지)

SELECT ENAME, HIREDATE, SAL, LAG(SAL,2, 0) OVER (ORDER BY HIREDATE ) AS PREV_SAL
FROM EMP
WHERE JOB='SALESMAN';

REM 그룹내 행 순서 함수-LEAD 함수

SELECT ENAME, HIREDATE, LEAD(HIREDATE, 1) OVER (ORDER BY HIREDATE ) AS NEXT_SAL
FROM EMP
WHERE JOB='SALESMAN';

REM 그룹내 행 순서 함수-LEAD 함수, LEAD(적용할 칼럼, 몇번째 뒤의 숫자를 가져올건지, NULL값일때 어떤값으로 표기할건지)


SELECT ENAME, HIREDATE, LEAD(HIREDATE, 2) OVER (ORDER BY HIREDATE ) AS NEXT_SAL
FROM EMP
WHERE JOB='SALESMAN';

REM 그룹 내 비율 함수-RATIO_TO_REPORT 함수

SELECT ENAME, SAL, ROUND(RATIO_TO_REPORT(SAL) OVER(), 2) AS R_R
FROM EMP
WHERE JOB = 'SALESMAN';

REM 그룹 내 비율 함수-PERCENT_RANK 함수

SELECT DEPTNO, ENAME, SAL,
       PERCENT_RANK() OVER(PARTITION BY DEPTNO ORDER BY SAL DESC) AS P_R
FROM EMP;

REM 그룹 내 비율 함수-CUME_DIST 함수

SELECT DEPTNO, ENAME, SAL,
CUME_DIST() OVER(PARTITION BY DEPTNO ORDER BY SAL) AS CUME_DIST
FROM EMP;

REM 그룹 내 비율 함수-NTILE 함수

SELECT ENAME, SAL, NTILE(4) OVER (ORDER BY SAL DESC) AS QUAR_TILE
FROM EMP;

REM 5-1절 ROWNUM 슈도 칼럼 - ORACLE전용 

SELECT ENAME, SAL
FROM(SELECT ENAME, SAL
FROM EMP
ORDER BY SAL DESC)
WHERE ROWNUM <=3;

REM 5-2절 TOP절 - SQL SERVER전용

SELECT TOP(2), ENAME, SAL
FROM EMP
ORDER BY SAL DESC;

SELECT TOP(2) WITH TIES, ENAME, SAL
FROM EMP
ORDER BY SAL DESC;

REM 5-3절 ROW LIMITING절 - ORACLE 12.1버전, SQL SERVER 2012버전부터 둘다 가능
SELECT EMPNO, SAL
FROM EMP
ORDER BY SAL, EMPNO FETCH FIRST 5 ROWS ONLY;

SELECT EMPNO, SAL
FROM EMP
ORDER BY SAL, EMPNO OFFSET 5 ROWS;


REM 셀프조인

SELECT E1.사원, E1.관리자, E2.관리자 차상위_관리자
FROM 사원 E1, 사원 E2
WHERE E1.관리자=E2.사원
ORDER BY E1.사원;

SELECT E1.사원, E1.관리자, E2.관리자 차상위_관리자
FROM 사원 E1 LEFT OUTER JOIN 사원 E2
ON ( E1.관리자=E2.사원)
ORDER BY E1.사원;

REM 2020책 
REM JONES의 자식 노드인 SCOTT와 FORD를 조회 (순방향 전개)
SELECT *
FROM EMP A, EMP B
WHERE A.ENAME='JONES'
AND B.MGR=A.EMPNO;

REM JONES의 자식 노드인 SCOTT와 FORD의 자식 노드인 SMITH와 ADAMS를 조회 (순방향 전개)
SELECT *
FROM EMP A, EMP B, EMP C
WHERE A.ENAME='JONES'
AND B.MGR=A.EMPNO
AND C.MGR=B.EMPNO;

REM SMITH의 부모 노드인 FORD를 조회 (역방향 전개)
SELECT *
FROM EMP A, EMP B
WHERE A.ENAME='SMITH'
AND A.MGR = B.EMPNO;

REM SMITH의 부모 노드인 FORD의 부모 노드인 JONES를 조회 (역방향 전개)
SELECT *
FROM EMP A, EMP B, EMP C
WHERE A.ENAME='SMITH'
AND A.MGR =B.EMPNO
AND B.MGR = C.EMPNO; 

REM https://blog.naver.com/ghrhzh/221983227669 계층형 쿼리


SELECT *
FROM EMP
ORDER BY JOB;

REM 
SELECT EMPNO, ENAME, JOB, MGR, LEVEL
FROM EMP
START WITH MGR = 7566
CONNECT BY NOCYCLE PRIOR MGR = EMPNO;

REM 
SELECT EMPNO, ENAME, JOB, MGR, LEVEL
FROM EMP
START WITH EMPNO = 7566
CONNECT BY NOCYCLE MGR = PRIOR EMPNO;

REM
SELECT LEVEL, LPAD('', 4 * (LEVEL-1))|| EMPNO AS EMPNO, MGR,
CONNECT_BY_ISLEAF AS ISLEAF
FROM EMP
START WITH MGR IS NULL
CONNECT BY PRIOR EMPNO = MGR;

REM 
SELECT LEVEL, LPAD('', 4 * (LEVEL-1))|| EMPNO AS EMPNO, MGR,
CONNECT_BY_ISLEAF AS ISLEAF
FROM EMP
START WITH EMPNO = 7369
CONNECT BY PRIOR MGR = EMPNO;

SELECT CONNECT_BY_ROOT (EMPNO) AS ROOT_EMPNO, SYS_CONNECT_BY_PATH(EMPNO, ',') AS PATH, EMPNO, MGR
FROM EMP
START WITH MGR IS NULL
CONNECT BY MGR = PRIOR EMPNO;